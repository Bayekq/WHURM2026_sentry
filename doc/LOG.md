# 更新日志&想法记录

## 2025-02-24

@Penguin

盲猜换串联腿后直接烧代码就能跑，只不过反馈值和实际值有亿点点偏差[doge]

## 2024-11-21

@ Penguin

v1.6.5更新日志

1. `平衡底盘`添加了离地检测
2. 优化了`平衡底盘`的参数
3. 优化了PID计算，对d加入了滤波，参数为0则不滤波输入数据
   > 考虑到基本不会用到该参数，未将滤波器系数添加到pid_init中，初始化为0，不对输入数据进行滤波。如需使用需要手动赋值。
4. 修改了低通滤波计算，参数为0则不滤波输入数据，统一并且更便于理解
   > 参数为0时不进行操作更加符合直觉。
5. 删除了电机反馈数据中参杂的电机信息相关的计算。
   > 保持了电机反馈值的原生性，将数据的处理交给用户去做。

## 2024-10-11

@ Penguin

之前测试的时候腿部支持力总是非常小，让我怀疑是不是机体质量有问题，今天拉去菜鸟驿站一量，发现还真是。

- 机体质量：8.5kg
- 单腿质量：3.5kg

比用图纸测量得到的数据小了好多。

## 2024-10-02

@ Penguin

在想自定义控制器的控制器时想到的一些事情：

1. 把 `4pin UART` 部分独立成 `communication-uart` 模块，方便自定义控制器调用接口和操作手电脑建立连接。
2. 保留 `communication_task` 用作板间通信任务，并在配置文件中添加相关配置内容。

> 简单来说把板间通信和PC通信分割开，任务中仅保留板间通信的控制，PC通信由自定义控制器任务进行控制。

## 2024-09-29

@Penguin

在优化平衡底盘ROLL角控制时想到的一些点：

1. 将ROLL角控制器的输出改为腿长差值，可以有效避免在双腿跨度过大的地形上直接控制输出力F导致的腿长范围超限问题。
   > 但是又带来了另一个问题：反应过于敏感，在微调时体现不出来，但出现大幅度的调整时就会开始震荡。
2. 为解决上面问题，打算从几何角度入手，结合当前Roll角、腿长和目标Roll角进行几何计算，得到目标腿长。再加上PI控制进行微调以达到目标值。

## 2024-08-24

@Penguin

在编写校准模式和裁判系统部分时发现了关于各模块间交互的一些问题。

之前使用的数据中转中心只能说算一个过渡方案，没有考虑到在加入裁判系统等部分后会有大量的数据中转的需求。一方面数据查询效率较低（但可以从算法层面优化）；另一方面要在任务中加入额外的发布和订阅环节，需要匹配发布和订阅的数据名，使用较为繁琐。

在结合过往代码编写经验和参考其他队伍的代码，有以下几个观点：

1. 每个模块都有固定的与外界交互的数据。
2. 现阶段的模块三层文件结构`task - model_type - model`中，底层 `model` 层几乎没有任何参与感，实际更像是`task - model_type`的二层结构。
3. 现有的数据交互比较不直观。

基于以上观点，作出如下的发展规划：

1. 为每个模块编写一套对外开放的api。
2. 将 `model` 的等级提高，与 `task` 并列，形成新的二层结构。
   > 注：`task` 层仅负责任务的处理逻辑，`model` 层负责与外界的交互。两者的共同点是只作出统一的接口定义，具体的函数实现则位于 `model_type` 层。
3. 采用函数指针，将api封装到结构体中，并于 `model` 层中对外开放与使用。
4. 保留数据中转中心功能至 `2024.12.01` ，之后停止数据中转中心的维护，并加上`.old`后缀。

> PS：兜兜转转，似乎又回到了dji的框架之下。

## 2024-08-23

@Penguin

针对自定义控制器和机械臂控制之间的链路有必要定下一套统一的通信协议了。

> 协议思路：机械臂直接接收执行量，即关节位置。自定义控制器中将关节位置解算完后再发出。\
> 协议内容：每个控制帧由7个轴(28 Bytes)位置和 2 Bytes的额外控制数据组成。（每个关节的位置采用float类型记录，自定义控制器链路提供了 30 Bytes的数据帧载体。）

之前是打算一套控制器，一个对应的协议。但处理起来过于麻烦，不如将解算置于控制器中，将控制器与对应的机械臂绑定一起，直接解算出目标量并发送。这样还省去了`CUSTOM_CONTROLLER_MODE`这个选项，无需处理接收数据，机械臂拿来就可以用。

## 2024-08-16

@Penguin

今天在平衡底盘添加机体速度观测器的时候发现状态更新部分写的有些混乱，出现了一些变量先用后更新的情况，需要改正一下。

## 2024-08-05

@Penguin

### IDEA

虽然发生的概率很低，但还是要考虑一下切换控制数据源的备用方案，监测遥控器和裁判系统的掉线情况，当遥控器掉线时切换至图传链路中的同步发送的键鼠数据。

数据源：

1. 遥控器数据
2. 图传键鼠数据
3. UART同步其他板的数据
4. CAN同步其他板的数据

> 可以考虑创建一个 Monitor Task 实现对整车外接设备状态的一个监测。

## 2024-08-03

@Penguin

发现原来的校准任务中只有陀螺仪校准，没有加速度计校准，后面要加上。

## 2024-08-01

@Penguin

思考了一下，在新框架之下，思维也要切换过来。需要提高模块本身的自由度，将参数配置放在配置文件中。

功能可以不用，但是必须要有。

## 2024-07-28

@Penguin

更新了全新的校准任务，更适合现在的车车。

## 2024-07-27

@Penguin

再思考了一下，还是沿用之前的设计，将校准单独组成一个任务。方便统一进行校准任务的调度，而且还要涉及到遥控器失能的操作。

要想办法把校准模式中的蜂鸣器部分移至到music部分，校准任务里只需激活music任务中的对应蜂鸣器叫声即可。

## 2024-07-26

@Penguin

突发奇想，当接收到数据的时候记录下时间，每次循环的时候计算当前时间与最新记录时间之间的间隔，大于阈值时便可判断为没有usb设备连接。

- +1：USB_Receive 每次读取操作都会将数据搬运到缓冲区中，即便没有接收到数据。这时可以根据上位机添加的时间戳来判断数据是否更新。
- +1：当 usb 离线状态接收到数据后不应该直接将离线标识符置为false，应该等待连续几次稳定的接收到数据后再将变化标识符。

### IDEA

1. 考虑将校准任务可以拆分开来，分散到各个模块的任务中。（但是又感觉单独的一个校准任务比较好管理校准数据，毕竟总要把数据从flash中读出来存放到某个变量中）
2. 上位机下发数据中的时间戳可以为基于上位机获得的时间戳，而非与下位机时间对齐。（后续如果有对时间戳进行更多的应用的化要重新考虑时间戳时间基点）

### NOTE

> 其实本文件创建的目的就是为了记录开发过程中的更新内容，不过第二天觉得在有 git graph 和大量提交信息的情况下没有必要单独写一个日志文件来记录。这导致了本文件自创建以后便一直没有被动过。今天在浏览交龙自瞄开源时发现他们的更新日志写的非常好、非常详细，清晰的看到思考过程和各种想法的记录。加上一般提交信息都比较简短，只能简要描述变化内容，不能很好的记录下思考和奇怪点子，于是乎我便打算继续在这个文件中记录更新日志了。

## 2024-07-25

@Penguin

确定了标签版本的命名方法：
x.y.z-release-beta

- x:重大版本更新时++（基本不会遇到吧，不出意外应该一直是1）
- y:新增模块内容时++
- z:小更新/修复bug++
- 如果是要创建发行版的标签，应该加上后缀<-release>，测试版本再接<-beta>

> 当版本号++后，其后面的小版本号都归零重新计数

尝试添加宏函数来进行每个函数中行为类似的发送间隔检查操作，因为今天又因为复制代码忘记改变量名出现奇怪BUG了。

## 2024-03-27 ~ 2024-07-25

未记载，过于久远了。

## 2024-03-27

@Penguin

在看到各组代码相互黑盒，不透明，复用性极差，以及战队电控成员质量参差不齐的情况下决定开始基于大家所熟悉的dji c板示例代码 `20.standard_robot` 开始开发本框架。

因为是基于 `20.standard_robot` ，所以名字也就叫做 `StandardRobot++` 啦
